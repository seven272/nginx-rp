user root;
worker_processes 1;

events {
    worker_connections 4096;
    multi_accept on;
    use epoll;
}


http {
    # upstream budget_frontend {
    #     server budget_client_container:4030; # <-- порт серевера nginx react приложения
    # }
    # upstream budget_backend {
    #     server budget_server_container:5050; # <-- порт server приложения
    # }
    # upstream prank_sound_frontend {
    #     # production
    #     # server prank_client_container:4000; # <-- порт серевера nginx react приложения

    #     # development
    #     server prank_client_container:3000; # <-- порт react приложения
    # }
    # upstream prank_sound_backend {
    #     server prank_server_container:5000; # <-- порт server приложения
    # }

    server {
        listen 80;
        server_name prank-sound.ru www.prank-sound.ru sportplans.ru www.sportplans.ru;# <-- можно указывать разные другие домены
        return 301 https://$host$request_uri;
    }


    # сервер приложения Звуковые пранки
    server {
        # listen 80;
        # listen [::]:80;
        listen 443 ssl;
        # если в proxy-pass использую переменные , то указываю DNS Docker для обновления IP адресов
        resolver 127.0.0.11 valid=10s;

        ssl_certificate /etc/letsencrypt/live/prank-sound.ru/fullchain.pem; # managed by Certbot
        ssl_certificate_key /etc/letsencrypt/live/prank-sound.ru/privkey.pem; # managed by Certbot

        root /var/www/html;
        index index.html index.htm ;
        server_name prank-sound.ru www.prank-sound.ru;
        # Увеличиваем максимальный размер загружаемого файла (по умолчанию 1МБ)
        client_max_body_size 20M;

        location / {
            # Важно порт для разработки 3000 / порт для продакшена 4000(сервер)

            # Записываем имя сервиса в переменную
            set $prank_frontend "http://prank_client_container:3000";
            # proxy_pass
            proxy_pass $prank_frontend;
            # Помогает «перепрыгнуть» на живой контейнер, если одна из копий упала
            proxy_next_upstream error timeout invalid_header http_502;
            proxy_connect_timeout 2s;
            # proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Поддержка WebSocket (нужно для Vite HMR / Hot Reload)
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }
        location /api {

            # Записываем имя сервиса в переменную
            set $prank_backend "http://prank_server_container:5000";
            # proxy_pass
            proxy_pass $prank_backend;
            # Помогает «перепрыгнуть» на живой контейнер, если одна из копий упала
            proxy_next_upstream error timeout invalid_header http_502;
            proxy_connect_timeout 2s;
            # proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Поддержка WebSocket (нужно для Vite HMR / Hot Reload)
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }
        # Проксирование статических файлов Multer
        location /static {
            # Записываем имя сервиса в переменную
            set $prank_static "http://prank_server_container:5000";
            # Запросы на http://domain.com/static
            # будут уходить на https://backend:5000/src/uploads/image.jpg
            proxy_pass $prank_static;
            # Помогает «перепрыгнуть» на живой контейнер, если одна из копий упала
            proxy_next_upstream error timeout invalid_header http_502;
            proxy_connect_timeout 2s;
            # Добавляем кеширование для ускорения работы
            expires 30d;
            add_header Cache-Control "public, no-transform";
        }
    }
    # сервер приложения Бюджет
    server {
        # listen 80;
        # listen [::]:80;
        listen 443 ssl;
        # если в proxy-pass использую переменные , то указываю DNS Docker для обновления IP адресов
        resolver 127.0.0.11 valid=10s;

        ssl_certificate /etc/letsencrypt/live/sportplans.ru/fullchain.pem; # managed by Certbot
        ssl_certificate_key /etc/letsencrypt/live/sportplans.ru/privkey.pem; # managed by Certbot

        root /var/www/html;
        index index.html index.htm ;

        server_name sportplans.ru www.sportplans.ru;

        location / {
            # Записываем имя сервиса в переменную
            set $budget_frontend "http://budget_client_container:4030";

            # proxy_pass
            proxy_pass $budget_frontend;

            # Помогает «перепрыгнуть» на живой контейнер, если одна из копий упала
            proxy_next_upstream error timeout invalid_header http_502;
            proxy_connect_timeout 2s;

            # proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Поддержка WebSocket (нужно для Vite HMR / Hot Reload)
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        location /api {

            # Записываем имя сервиса в переменную
            set $budget_backend "http://budget_server_container:5050";

            # proxy_pass
            proxy_pass $budget_backend;

            # Помогает «перепрыгнуть» на живой контейнер, если одна из копий упала
            proxy_next_upstream error timeout invalid_header http_502;
            proxy_connect_timeout 2s;

            # proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Поддержка WebSocket (нужно для Vite HMR / Hot Reload)
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

    }

}

# примечания
# Если для навигации используется upstream то нужен / на конце в proxy_pass для фронтенда, если переменные то / не нужен!